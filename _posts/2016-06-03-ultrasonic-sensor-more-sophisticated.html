---
layout: post
title: 'Ultrasonic sensor: A more sophisticated scanning and decision making - The AuRGent Project'
date: '2016-06-03T07:08:00.000+02:00'
author: Sotaya Yakubu
tags: [arduino,microcontroller,chassis]
categories: [Arduino]
modified_time: '2016-06-03T07:08:54.438+02:00'
blogger_orig_url: http://plaixes.blogspot.com/2016/06/ultrasonic-sensor-more-sophisticated.html
icon: fa-robot
---

I will start by saying "its been too long", to say its due to research projects at the university. However, I made some decent improvements in my <b>AuRGent</b> robot project, previously you just saw a basic navigation with hard coded movement. Recently I took the liberty of purchasing an ultrasonic sensor servo mount and hooked it up to my <i>Arduino</i> board, thus allowing the Robot to make some sort of decision based on its precepts from the sensor. Keep on reading, more details below. <b></b><b></b> <h2>The Sensor, mount and Servo</h2> From the figure below, you see exactly how i mounted the sensor to the mount and thus to the servo, this allows me to program the ultrasonic range sensor to scan 165 &deg;, taking readings at 0 &deg; (the right distance), at 90 &deg; (the center distance) and at 165 &deg; (the left distance). Why 165 you ask? Well i left some room to accommodate the error in servo (keep in mind you have to experiment to find your value).  <div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-ZwlnsIdcJrc/V1D7PI8pnlI/AAAAAAAAAo0/kYU3c7i8XNUqhBh616AkRVQm0ApjunGSQCLcB/s1600/20160603_052401-1.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://2.bp.blogspot.com/-ZwlnsIdcJrc/V1D7PI8pnlI/AAAAAAAAAo0/kYU3c7i8XNUqhBh616AkRVQm0ApjunGSQCLcB/s320/20160603_052401-1.jpg" /></a></div> What happens here is, as the robot navigate, the sensor is at 90 &deg;, now whenever there is an obstacle in >=40cm, the bot stops, scans around taking a reading of both left and right and then makes a decision to take the path (left or right) with the highest distance to another obstacle. Okay okay am just going to give you the <b>code</b>.  <pre class="brush:c"><br />    cm = get_distance();<br />    motor_speed = get_motor_speed(cm);<br />    type = bot_move(motor_speed, cm); <br />    if( type == 1){<br />        servo2.write(0); <br />        delay(500);<br />        right = get_distance(); //scan to the right<br />        delay(500);<br />        servo2.write(165);<br />        delay(600);<br />        left = get_distance(); //scan to the left<br />        delay(500);<br />        servo2.write(90); //return to center<br />        delay(100);<br />        compareDistance();<br />    }<br /></pre> What you see here is the loop, we get the distance from the sensor with the <pre>get_distance()</pre> function.  <pre class="brush:c"><br />    int get_distance(){<br />        // establish variables for duration of the ping,<br />        // and the distance result in inches and centimeters:<br />        long duration, cm;<br />        digitalWrite(trig, LOW);<br />        delayMicroseconds(5);<br />        digitalWrite(trig, HIGH);<br />        delayMicroseconds(15);<br />        digitalWrite(trig, LOW);<br />        duration = pulseIn(echo, HIGH);<br />        cm = microseconds_to_centimeters(duration); //Converting distance to cm<br />        return cm;<br />    }<br /></pre> Based on that (left and right), the distance is read by the function <pre>compareDistance()</pre> which makes the decision on which path to take next.  <pre class="brush: c"><br />    void compareDistance(){<br />  <br />        if (left>right) //if left is less obstructed <br />        {<br />            turn_left();<br />            delay(500); <br />        }<br />        else if (right>left) //if right is less obstructed<br />        {<br />            turn_right();<br />            delay(500);<br />        }<br />        else //if they are equally obstructed<br />        {<br />            turn_right();<br />            delay(1000);<br />        }<br />    }<br /></pre> That easy right?  <p> Well you have seen most of the rest of the code in my previous posts, however i have restructured some movements, like for instance the function calls to left, right, back and forward in specialized function calls. Am just gonna give it to you and you figure out the rest. But just for argument sake, here are some specialised function calls you can find in the code:<b></b><b></b><ul>    <li><pre>get_motor_speed()</pre> function just takes in a distance as argument and uses <pre>map()</pre> to find a suitable speed for the bot given the distance, setting it to the global <i>motor_speed</i> variable.</li>    <li><pre>set_speed()</pre> function takes in the motorspeed as argument and sets it to each of the motors (front left and right, back left and right).     <li><pre>bot_move()</pre> function on the other hand takes both the distance and speed based on the previous functions, decides how should the bot move given this variables, it also sets the speed of the motors.</li></ul> Now you ask doesn't <i>bot_move</i> and <i> compareDistance()</i> do the same thing? No not the same, you see the first decides on whether to keep going forward, go backwards, go left or go right even at the initial state where there is no current reading yet. However, the prior only apply's only when we encounter and obstacle while going in a forward direction, then it decides to turn left or right. <b></b><b></b> <h2> Current AuRGent Structure </h2> <div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-fxH0Zgltfis/V1EFF8yQPpI/AAAAAAAAApE/uciCIMUfhVw9A5rq8MLAHEKXVN7FxKDnwCLcB/s1600/20160412_212605.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://1.bp.blogspot.com/-fxH0Zgltfis/V1EFF8yQPpI/AAAAAAAAApE/uciCIMUfhVw9A5rq8MLAHEKXVN7FxKDnwCLcB/s320/20160412_212605.jpg" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-XyUcAECPjHU/V1EFGGcTi1I/AAAAAAAAApM/2iQO3_4w3aQdmB__s4qObsy3oeDANvf6ACLcB/s1600/20160412_212620.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://4.bp.blogspot.com/-XyUcAECPjHU/V1EFGGcTi1I/AAAAAAAAApM/2iQO3_4w3aQdmB__s4qObsy3oeDANvf6ACLcB/s320/20160412_212620.jpg" /></a></div> I think i can say we covered the most important aspects of this issue, if you need the full code kindly go to my repo <a href="https://github.com/Rootex/AuRGent">GitHub</a> and the video for this feature will be made available momentarily on my channel <a href="http://www.youtube.com/c/SotayaYakubu">YouTube</a><b></b><h2> Coming soon: Upgrades</h2><ul>    <li>FSM (Finite State Machine): So honestly i hate my implementation with the bunch of if-then-else, on my defense, this solution was a preliminary hack solution. However in the next issue on this project, i will introduce FSM and a refactored version of my code which will also be in the repo.</li>    <li>Reinforcement Learning: I am still designing my policy matrix to enable my bot to learn from experience and come up with its own optimal policy instead of my approximate policy in the current implementation.</li>    <li>Task and path finding: I will also implement using a GPS and Compass module a feature to enable navigation from a given state to another with (as much as i can) optimal solution.</li></ul><b></b><b></b> Thanks and if you love my posts and videos, don't forget to share, comment on improvements i can make to either the post, videos or projects, learning never ends. 
