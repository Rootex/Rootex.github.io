---
layout: post
title: Hooking up SainSmart Motor Shield, Ultrasonic Range Finder with Arduino to
  Control my Chassis.
date: '2015-12-21T21:32:00.000+01:00'
author: Sotaya Yakubu
tags:
- sain smart
- SR04
- chassis
- Arduino
- ultrasonic sensor
modified_time: '2015-12-21T22:09:57.955+01:00'
thumbnail: http://4.bp.blogspot.com/-v_5I83qcJ_s/VnhdnSdt4WI/AAAAAAAAAnY/pH_jV8l1EA8/s72-c/20151221_203147.jpg
blogger_id: tag:blogger.com,1999:blog-612978290615405441.post-2426803382838751015
blogger_orig_url: http://plaixes.blogspot.com/2015/12/hooking-up-sainsmart-motor-shield.html
---

Its been long since the last post on the series, a lot has changed since then.  <br><h2>Motors to Motor Shield</h2><br>I had problems with the right motor shield to use, however i finally settled with the sain smart motor shield, which has its library called <a href="https://learn.adafruit.com/adafruit-motor-shield/library-install">AFMotor</a> with a guide at the link on how to set it up. <br>Once you install in your arduino IDE, all is left is to connect it to your arduino like this: <br><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-v_5I83qcJ_s/VnhdnSdt4WI/AAAAAAAAAnY/pH_jV8l1EA8/s1600/20151221_203147.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-v_5I83qcJ_s/VnhdnSdt4WI/AAAAAAAAAnY/pH_jV8l1EA8/s320/20151221_203147.jpg" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-uNgaXVDPybM/VnhdnR4k9vI/AAAAAAAAAnc/mCsfqKl7DYY/s1600/20151221_203208.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-uNgaXVDPybM/VnhdnR4k9vI/AAAAAAAAAnc/mCsfqKl7DYY/s320/20151221_203208.jpg" /></a></div><br>and then first import the library with some few definitions. <br><pre class="brush: c"><br /><br />#include <AFMotor.h><br />#define MAX_SPEED 120<br />#define MIN_SPEED 95<br /></pre><br>     You speed can vary, so make sure you experiment with various speed. <br>In my case i have 4 motors i want to control, so i hooked up the front motors to M1 and M2 respectively and the back to M3 and M4, then declare the motor instances like this: <br><pre class="brush: c"><br /><br />&nbsp;AF_DCMotor motorlf(1);<br />&nbsp;AF_DCMotor motorrf(2);<br />&nbsp;AF_DCMotor motorlb(3);<br />&nbsp;AF_DCMotor motorrb(4);<br /><br /></pre><br>after this, you will need to put this code in your setup. <emp>Setting the speed</emp><br><pre class="brush: c"><br /><br /> &nbsp; motorlf.setSpeed(MIN_SPEED);<br />&nbsp;  motorrf.setSpeed(MIN_SPEED);<br /> &nbsp; motorlb.setSpeed(SLOW_SPEED);<br />  &nbsp;motorrb.setSpeed(SLOW_SPEED);<br /><br /></pre><br>then for each motor you can use for example <br><pre class="brush: c"><br />&nbsp;motorlf.run(FORWARD);<br />&nbsp;motorrf.run(BACKWARD);<br /></pre><br>The rest is basic programming. Also take not that if you want to turn right, you can set the left wheel to run forward and the right wheel to run backward, the converse for turning left. <br><h2>Ultrasonic Range Finder</h2><br>For the sensor, hook up the VCC to arduino board 5v, Gnd to Gnd, Trig to pin 12, echo to pin 13 like in the image above, you can see the 2 wires running into the board at both ends. <br>Then also define this in your code <br><pre class="brush: c"><br />&nbsp;#define trig  12 <br />&nbsp;#define echo 13 <br /></pre><br>and in setup add  <br><pre class="brush: c"><br />  &nbsp;pinMode (trig,OUTPUT);<br />  &nbsp;pinMode (echo,INPUT);<br />  // initialize serial communication:<br />  &nbsp;Serial.begin(9600);  <br /></pre><br>then in your loop <br><pre class="brush: c"><br />  &nbsp;digitalWrite(trig, LOW);<br />  &nbsp;delayMicroseconds(2);<br />  &nbsp;digitalWrite(trig, HIGH);<br />  &nbsp;delayMicroseconds(10);<br />  &nbsp;digitalWrite(trig, LOW);<br />  &nbsp;duration = pulseIn(echo, HIGH);<br />  &nbsp;cm = (duration / 2) / 29.1;<br />   &nbsp;if(cm > 25){<br /><br />    &nbsp;move_forward();<br /><br />  &nbsp;}else{<br />    <br />    &nbsp;turn_right();<br />    &nbsp;delay(300);<br />    <br />  &nbsp}<br /></pre><br>So what this basically does is it sets a low pulse for about 2 microseconds to ensure a clean high pulse for a longer period, set back to low and reads the echo using pulseIn. Thats the duration. You can see the calculation to CM in the code above. <br>Finally our robot looks like this <br><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-vrKeNJk_65I/VnheQXR1dqI/AAAAAAAAAno/CgOJ8bvgU_k/s1600/20151221_210846.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-vrKeNJk_65I/VnheQXR1dqI/AAAAAAAAAno/CgOJ8bvgU_k/s320/20151221_210846.jpg" /></a></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-PKSLeEcTqBQ/VnheSvb4PNI/AAAAAAAAAnw/0Skncq2_cPc/s1600/20151221_210912.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-PKSLeEcTqBQ/VnheSvb4PNI/AAAAAAAAAnw/0Skncq2_cPc/s320/20151221_210912.jpg" /></a></div><br>Upload your code and start your bot. Anytime it encounters an obstacle less than 25 cm, it turns right, from this you can make even more sophisticated computations. <br>Check out my <a href="https://youtu.be/AHPLOpkFoGY">Youtube</a> video for detailed explanation.